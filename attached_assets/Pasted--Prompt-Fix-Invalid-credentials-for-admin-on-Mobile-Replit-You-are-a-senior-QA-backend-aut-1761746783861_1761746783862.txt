ðŸ”§ Prompt: Fix â€œInvalid credentialsâ€ for admin on Mobile (Replit)

You are a senior QA + backend auth engineer.
Target: My Replit app shows â€œLogin Failed â€” Invalid credentialsâ€ for admin on mobile. Desktop sometimes works.
Produce: Root cause + exact fix + verification steps with evidence (logs/SQL/curl).

Stack hints: Replit hosting, standard username+password login. May be Node/Express + (Prisma/SQL or Supabase).
Treat this as production and give code/config I can paste.

1) Reproduce & capture evidence (mobile-first)

Use Incognito (no extensions). Clear cookies/storage.

Turn off Auto-Fill, Auto-Correct, Auto-Capitalize, Smart Punctuation on the keyboard.

Try username admin and the known password. If failed, tap â€œshow passwordâ€ and confirm characters.

Collect:

Exact request & response for /auth/login (status, body).

If possible, attach a HAR from Mobile Web Inspector (Safari iOS via macOS or Chrome Remote Debugging).

Screenshot of the error banner.

Quick Unicode test (in login field):

Type admin and backspace once â†’ if a hidden character remains, the cursor wonâ€™t moveâ€”flag possible zero-width chars.

Copy the entered password to a temporary text box and show code points to detect zero-width space (U+200B) or non-breaking space (U+00A0).

2) Client-side hard checks

Ensure the login form trims and normalizes input before sending:

// Run before submit (frontend)
const nfkc = s => s.normalize?.("NFKC") ?? s;
const clean = s => nfkc(s).replace(/\s+/g, " ").trim();
const loginId = clean(form.login.value).toLowerCase(); // if usernames are case-insensitive
const password = nfkc(form.password.value).trim();     // do NOT lower-case passwords


Disable mobile autocorrect on inputs:

<input ... autocapitalize="none" autocomplete="username" autocorrect="off" spellcheck="false" />
<input type="password" ... autocomplete="current-password" autocapitalize="none" autocorrect="off" />


If password manager/autofill changes characters (e.g., replaces .), turn it off and retest.

3) Server-side verification (decide reason of â€œinvalidâ€)

Log at INFO level what failed (without leaking secrets):

// Pseudocode in your login handler
const rawUser = req.body.loginId ?? "";
const rawPass = req.body.password ?? "";
const norm = (s:string)=> s.normalize("NFKC");
const loginId = norm(rawUser).trim();
const pass    = norm(rawPass);

// If usernames are case-insensitive:
const loginKey = loginId.toLowerCase();

const user = await db.user.findFirst({
  where: { OR: [{loginId: loginKey},{loginId: loginId}] } // cover both if legacy
});

if(!user){ log.info({loginId},"auth_fail:user_not_found"); return 401; }

const ok = await bcrypt.compare(pass, user.passwordHash);
if(!ok){ log.info({userId:user.id},"auth_fail:bad_password"); return 401; }

log.info({userId:user.id},"auth_ok");


Also enforce backend trim/normalize regardless of UI to defeat hidden Unicode from mobile keyboards.

4) Database & seed sanity (most common real root cause)
4.1 Confirm the admin row

Postgres/SQL

SELECT id, login_id, status, LENGTH(password_hash) AS len, created_at
FROM users
WHERE LOWER(login_id) = 'admin';


Expect 1 row, status='active', and password_hash length consistent with your hasher (bcrypt â‰ˆ 60 chars starting with $2).

If Supabase Auth

Check Authentication â†’ Users for admin email/ID and whether the user is confirmed and not banned.

4.2 Detect double-hash or wrong algorithm

If your seed script stored a plain text or already hashed password and your auth hashes again at login, compare will always fail.

Fix the seeder to hash exactly once:

import bcrypt from "bcryptjs";
const hash = await bcrypt.hash(process.env.ADMIN_PASS, 12);
await prisma.user.upsert({
  where:{loginId:"admin"},
  update:{passwordHash:hash, status:"active"},
  create:{loginId:"admin", passwordHash:hash, role:"ADMIN", status:"active"}
});

4.3 ENV mismatch on Replit

On Replit, set Secrets (ADMIN_PASS, DATABASE_URL, etc.). .env file in repo is ignored at runtime unless you load it.

Make sure the value you think is the admin password is actually the one used during seed.

Re-run the seed command and capture output timestamps.

5) Rate-limit / lockout & casing

Some backends lock the user after N failed attempts â†’ mobile could be locked while desktop isnâ€™t.

Check failed_attempts, locked_until. Clear them:

UPDATE users SET failed_attempts=0, locked_until=NULL WHERE LOWER(login_id)='admin';


If usernames are intended to be case-insensitive, ensure both query and unique index use LOWER(login_id).

6) Minimal curl tests (bypass UI; prove where it fails)

Replace host:

# Attempt login with raw credentials (from the device or any terminal)
curl -i https://<your-app-host>/auth/login \
  -H "Content-Type: application/json" \
  --data '{"loginId":"admin","password":"<ADMIN_PASSWORD>"}'
# Expect 200 with token/cookie. If 401 here, the issue is NOT the mobile UIâ€”it's DB/hash/ENV.


If using cookies, test session:

# After capturing Set-Cookie from previous, call a protected route
curl -i https://<your-app-host>/me \
  -H 'Cookie: session=<paste session cookie>'

7) Mobile-specific pitfalls & permanent fixes

Hidden characters: iOS can insert zero-width or non-breaking spaces. Permanently fix by Unicode NFKC normalization and trim on server.

Auto-capitalization: Ensure <input> disables it; also lower-case username on server for match.

Locale digits: Some keyboards use non-ASCII digits; NFKC normalizes them.

Emoji/Smart punctuation: NFKC reduces risk; additionally reject non-printable/control chars and log them:

const sanitized = s => s.normalize("NFKC").replace(/[\u0000-\u001F\u007F\u200B\u00A0]/g,"").trim();


Password visibility: Provide a â€œshowâ€ toggle to visually confirm entry on phone.

8) If we need to reset admin safely (one-time)

Generate a strong temporary password and force change on first login:

const tmp = "Supremo@"+Math.random().toString(36).slice(2,8);
const hash = await bcrypt.hash(tmp, 12);
await prisma.user.update({ where:{loginId:"admin"}, data:{ passwordHash:hash, mustChangePassword:true }});
console.log("TEMP_ADMIN_PASSWORD=", tmp);


Send me the console value; keep it private.

9) Deliverables to return

The log line that shows which branch failed: user_not_found vs bad_password.

A screenshot of the SQL row for admin (redact hash).

The seed script snippet (before/after) showing correct single bcrypt hash.

The curl output of /auth/login returning 200 after the fix.

10) Verification checklist (done on mobile + desktop)

 admin can login on mobile and desktop with same password.

 Subsequent /me returns 200; session persists after refresh.

 Input normalization in place (server).

 Seeder idempotent; no double-hash.

 Lockout/rate-limit verified and documented.

Quick drop-in snippets (Node/Express)

Route:

import bcrypt from "bcryptjs";

app.post("/auth/login", async (req,res) => {
  const nfkc = (s:string)=> (s||"").normalize("NFKC");
  const sanitize = (s:string)=> nfkc(s).replace(/[\u0000-\u001F\u007F\u200B\u00A0]/g,"").trim();

  const rawUser = sanitize(req.body.loginId);
  const rawPass = nfkc(req.body.password||"");

  const loginId = rawUser.toLowerCase(); // if case-insensitive
  const user = await prisma.user.findFirst({ where:{ loginId } });

  if(!user) { return res.status(401).json({error:"invalid_credentials"}); }

  const ok = await bcrypt.compare(rawPass, user.passwordHash);
  if(!ok)   { return res.status(401).json({error:"invalid_credentials"}); }

  // â€¦issue session/cookie/JWTâ€¦
  return res.json({ ok:true });
});


HTML inputs:

<input name="loginId" autocapitalize="none" autocorrect="off" spellcheck="false" autocomplete="username" />
<input name="password" type="password" autocapitalize="none" autocorrect="off" autocomplete="current-password" />